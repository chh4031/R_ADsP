##디렉토리 설정
getwd() #현재 위치
setwd() #위치 변경

##실행은 F5나 ctrl + R, 해당 커서로 실행 또는 드래그로 선택해서 실행

## 패키지 사용하기

path.package()                #현재 활성화된 패키지들이 무엇인지 확인

data(Animals)                 #하드디스크에 MASS 패키지를 실행하지 않았기 때문에 파일이 없는것으로 나옴

library(MASS)                 #MASS 패키지를 라이브러리에 설치
data(Animals)                 #데이터 확인 가능
Animals
summary(Animals)

install.packages("dplyr")       #패키지 설치
library(dplyr)                  #패키지 로드

## 기본적인 기능

#디렉토리 만들기
                                #현재 작업 중인 폴더의 경로(주소) 산출
                                #작업 폴더 만들기
                      		      #작업 폴더를 새로 지정


#도움말
?함수명
?max
help(함수명)
help(max)
RSiteSearch("함수명")		#max의 논문이나 문서를 모두 보여줌
RSiteSearch("max")

#편리한 기능

dir()                           #현재 작업 중인 폴더에 있는 파일 목록 산출
list.files()                    #파일 이름 확인하기
ls()                            #변수 목록 보기
rm()					  #선택 객체 삭제
rm(list=ls())                   #메모리의 모든 객체 삭제
q()                             #R 종료
;                               #명령어의 끝을 명시
print()                         #출력



### R 기초

##변수 생성 : 대입연산자( <-, <<-, =, ->, ->> )를 사용하며, <-를 가장 권장

#변수 생성시 변수 명의 규칙 
#    ① 변수명에는 알파벳, 숫자, _(언더스코어), .(마침표)를 사용할 수 있다.
#    ② 첫 글자는 마침표 혹은 알파벳으로 시작이 가능하며, 마침표로 시작할 경우 
#       마침표 뒤에는 숫자가 올 수 없다.
#    ③ -(하이픈)은 변수명에 사용할 수 없다.
#
#      * 올바른 변수명 : x, y, abc_1, efg.2
#      * 잘못된 변수명 : 1a, .3, x-y

name<-"Jane";                        #name 변수에 Jane 이라는 문자 할당
name
number<-c(1,2,3,4,5);                #number변수에 숫자 1,2,3,4,5를 할당
number

#기초 연산자 : 연산자 우선순위에 따라 예시를 설명

#산술 연산자
5^2                 	# ^ : 지수
+3; -5;                 # +- : 단항 플러스와 마이너스 부호
1:30                	# ":" :수열 생성
3%/%3                	# %/% : 나눗셈의 몫
3%%3                	# %% : 나눗셈의 나머지
3%*%3                	# %*% : 행렬곱
2*5; 10/2;              # *,/ : 곱하기, 나누기
3+4; 5-2;               # +,- : 더하기, 빼기

#비교연산자
3==5                 		  # == : 좌우의 값이 같은지 비교하여 TRUE/FALSE로 반환
3!=5; 4<1; 4>1;                 # !=,<,> : 좌우의 값이 다른지 비교하여 TRUE/FALSE로 반환
8<=3; 9>=4;                 	  # <=, >= : 크거나 같다, 작거나 같다를 비교하여 TRUE/FALSE로 반환
!(3==4)                 	  # ! : 논리 부정
3==4 & 4==3                	  # & : 논리 AND로 논리 연산 데이터가 하나일 때 &&, 하나 이상일 때 &
5==3 | 3==2                	  # | : 논리 OR로 논리 연산 데이터가 하나일 때 ||, 하나 이상일 때 |
y~a*x+b                		  # ~ : 식(formula)로 종속변수 ~ 독립변수1 + 독립변수2 ... y=ax+b의 표현




## 데이터 타입
#c는 여러개의 데이터를 저장할때 사용한다.
# 1) 숫자형(numeric) : 정수, 실수, 복소수 등을 숫자형 데이터 타입으로 지원하며 수학, 통계적 연산 가능
a<-c(1.1,-5)
a

# 2) 문자형(character) : " " 또는 ' ' 내에 문자형 데이터가 표현되며 연산이 불가능 산술은 불가, 비교는 가능
b<-c("Bigdata")
b

# 3) 논리형(logical) : 이진값을 갖는 데이터타입, TRUE(T,1)는 참, FALSE(F,0)는 거짓을 의미, 1과 0로 표현되기 때문에 수치형 데이터로 변환 가능, 연산 가능
(3==4)
(4==4)
(3==4)+(4==4)+(5==4)



# 4) 팩터(factor) : 범주형 자료를 표현하기 위한 데이터 타입, factor함수 이용
#   factor(data,        # 범주형으로 표현하고자 하는 데이터
#          levels,      # 레벨의 목록 (구분하고자 하는 범주수준)
#          labels,      # 범주수준에 따른 표시 값
#          ordered)     # TRUE이면 순서형(학번 같이 순서가 있는것), FALSE이면 명목형(남자 여자와 같이 순서가 딱히 없는것)



성별<-factor(c("M","M","F","F","F"), levels=c("F","M"), labels=c("여","남"), ordered=F)
성별

# 5) NA/NULL/NAN/INF : NA는 결측치(관측되지 않은 비어있는), NULL은 정의되지 않은 값, NAN은 계산이 불가능한 값, INF는 무한대

c<-c(1,3,"dog",NA,NULL)                        #NA의 경우 벡터에 입력했을 때 나타나지만, NULL의 경우 정의되지 않은 값이므로 나타나지 않음
c
0/0                       			     #NaN
1/0    	                 			     #inf


# 6) 데이터 타입 확인
a<-c(1.1,-5)    
b<-c("Bigdata")
c<-factor(c("M","M","F","F","F"), levels=c("F","M"), 
          labels=c("여","남"), ordered=F)
d<-(3==4)

#맞으면 TRUE 틀리면 FALSE
is.numeric(a)                 #객체가 숫자형 벡터인가?
is.integer(a)                 #객체가 숫자형 벡터인가?
is.double(a)                  #객체가 숫자형 벡터인가?

is.character(b)               #객체가 문자형 벡터인가?
is.factor(c)                  #객체가 팩터인가?
is.logical(d)                 #객체가 논리형인가?

is.null(a)                	#객체가 NULL인지 판단
is.na(b)           		#객체가 NA인지 판단

# 7) 데이터 타입 변환
나이<-c(24,26,25,20,40,39,"29")                 #마지막 "29"로 인해 character형으로 생성됨 sum함수로 계산 불가
과목<-c("R","Python","Java","C","R","R","Java") 
성별<-factor(c("F","M","F","M","M","M","F"))

as.numeric(나이)                   #객체를 숫자형으로 변환
as.character(성별)                 #객체를 문자형으로 변환
as.factor(과목)                    #객체를 팩터로 변환




## R 데이터 구조
# 1) 벡터(vector) : R프로그래밍의 기본적인 데이터 단위, 벡터의 모든 원소는 같은 데이터 타입을 가짐
#                  벡터는 값의 위치를 인덱스로 사용하여 원소에 접근, [](대괄호)를 이용
#                  name 함수를 이용하여 벡터의 원소이름 부여 가능
#                  [](대괄호) 속에 조건문을 활용하여 벡터의 원소 선택 가능

z<-c(6,7,8,9,10)           #벡터 생성(원소 중 하나라도 문자형이 있으면 모두 문자형으로 변형됨)
z

z[2]                  	   #v벡터의 두 번째 원소 출력
z[c(1,3)]                  #z벡터의 첫 번째, 세 번째 원소 출력
z[-5]                  	   #z벡터의 다섯 번째 원소만 제외하고 출력
z[2:4]
z[1,3]			   #z[1,3]은 에러, 벡터는 1차원이다. 이거는 1행 3열의 표현 즉 행렬의 표현이다.

names(z)<-c("Kim","Lee","Park","Choi","Jeong");
z["Park"];                 	#결과로 원소 이름이 Park인 8이 출력됨
z[z>7]                  	#z벡터의 원소 중 7보다 큰 값만 출력

#rep(x, times, each) : x(벡터)를 times에 지정한 숫자만큼 반복
#                      times : 벡터 전체의 반복횟수
#                      each : 벡터 원소 각각의 반복횟수

rep(c("k",1), times=c(3,6))                            #k를 3번, 1을 6번 반복
rep(1:3, each=10)                           		 #1,2,3을 각각 10번씩 반복


#seq(from, to, by) : from부터 to까지 by만큼 증가하는 수열 생성
seq(from=1, to=10, by=2)                            # 1부터 10까지 2만큼 증가하는 수열

#벡터의 기초통계
필기점수<-c(89,86,85,92,93,91,90,89,81,84,85,89,92,95,96,91,93,92,90,90,92,91,93,92,90,92,92,93,94,99,95,96,94)
실기점수<-c(91,87,95,96,89,87,86,85,84,86,88,92,91,93,92,92,91,93,94,94,95,96,96,96,99,95,98,97,92,86,84,89,87)

mean(필기점수)                          	#변수의 평균 출력
sum(필기점수)                          	#변수의 합계 출력
max(필기점수)                          	#변수의 최대값 출력
min(필기점수)                          	#변수의 최솟값 출력
median(필기점수)                            #변수의 중앙값 출력
abs(필기점수)                          	#변수의 절댓값 출력
log(필기점수)                          	#변수의 로그값 출력
sd(필기점수)                          	#변수의 표준편차 출력
var(필기점수)                          	#변수의 분산 출력
cov(필기점수, 실기점수)                       #변수간 공분산 출력
cor(필기점수, 실기점수)                       #변수간 상관계수 출력
length(필기점수)                            #벡터의 길이(원소 개수)를 값으로 산출

#벡터 연산 수행
v1<-c(10,11,12,13,14)
v2<-c(1,2,3,4,5)
#각 자리수에 맞게 연산 수행
v1+v2
v1-v2
v1*v2
v1/v2
v1^v2

v1+2
v1-2
v1*2
v1/2
v1^2

#스칼라값이 되어 다룰 수 있다.
mean(v1)
v1-mean(v1)
(v1-mean(v1)/sd(v1))


###### recycling rule  ########
#자리수에 맞지 않으면 다시 처음 데이터로 넘어가서 실행(재활용 기술), 원래는 에러가 나면서 결과가 나타남.
a<-c(1,2,3,4,5,6)
b<-c(7,8,9)
a+b


# 2) 행렬(matrix) : 차원을 가진 벡터로, 행(로우)와 열(컬럼)의 수가 지정된 구조
#                  한 가지 유형의 데이터만 저장이 가능, 요소는 x[nrow,ncol]로 접근(x:행렬 객체, nrow:행번호, ncol:열번호)
#   matrix(data,            # 행렬에 저장할 데이터 (벡터)
#          nrow,           # 행의 수
#          ncol,            # 열의 수
#          byrow           # 행렬의 데이터 입력 순서(TRUE : 행우선, FALSE : 열우선)
#          dimnames)      # 행렬의 각 차원에 이름 부여, 없어도 되긴함. 단 dimnames 앞에꺼는 꼭 있어야함.

matrix(1:9, nrow=3, ncol=3, dimnames=list(c("r1","r2","r3"), c("a","b","c")))
matrix(1:9, nrow=3, ncol=3, byrow=T, dimnames=list(c("r1","r2","r3"), c("a","b","c")))

x<-c(1:9)
dim(x)<-c(3,3)               #dim()은 행렬 차원 확인 및 부여하는 함수. 
x               		     #x행렬에 3x3차원 부여
nrow(x)               	     #행의 수 확인
ncol(x)               	     #열의 수 확인
x[2,2]               	     #x행렬의 2행2열의 원소 추출
x[2,]              	     #x행렬의 2행의 원소 추출
x[,1]              	     #x행렬의 1열의 원소 추출
x[-3,]              	     #x행렬의 3행을 제외한 나머지 행 추출
x[,-2]               	     #x행렬의 2열을 제외한 나머지 열 추출

dimnames(x)<-list(c("r1","r2","r3"),c("a","b","c"))           # 행렬의 각 차원의 이름 부여
x                  

rownames(x)<-c("r4","r5","r6")                                #행 이름 출력 및 부여
x
colnames(x)<-c("e","f","g")                               	  #열 이름 출력 및 부여
x

t(x)                   #x의 전치행렬 반환
diag(x)                #행렬 x의 대각원소 반환, 중심축 반환


y<-matrix(1:4,2,2)
y
z<-matrix(5:8,2,2)
z
solve(y)              	 #y의 역행렬 반환
y+z; y-z;                #y,z 행렬의 각 원소간의 덧셈/뺄셈
y+3               	 #y행렬의 각 원소에 숫자 3을 더함
y*3               	 #y행렬의 각 원소에 숫자 3을 곱함
y%*%z                    #y행렬과 z행렬 간의 곱셈

# 3) 데이터프레임(data.frame) : 데이터프레임은 벡터 객체들의 모임이며, 데이터 프레임에 속한 벡터들은 서로 다른 데이터 타입을 가질 수 있음
#data.frame(변수명1=벡터1, 변수명2=벡터2, 변수명3=벡터3...,
#           stringAsFactors=TRUE)  
# stringAsFactors : 문자열을 팩터로 저장할지의 여부 

ex<-data.frame(x=c(1:6), y=c("가","나","다","라","마","바"), z=c("a","b","c","d", "e", "f"))
ex

ex[2,1]              #ex의 2행1열의 원소 출력
ex[-2,]              #ex의 2행을 제외한 데이터 출력
ex[,1]               #ex의 1열의 모든행 출력

colnames(ex)<-c("a","b","c")                                   #ex 데이터의 열 이름을 a, b, c로 지정
ex$a              							   #ex 데이터의 a열 출력
 
ex2<-data.frame(a=c(5,6,7), b=c("라","마","바"),c=c("d","e","f"))
ex2

rbind(ex,ex2)              #ex와 ex2를 행으로 결합(결합할 두 객체의 열의 개수와 열의 이름이 동일해야 함)
cbind(ex,ex2)              #ex와 ex2를 열으로 결합(결합할 두 객체의 행의 개수와 열의 이름이 동일해야 함)
             		   #recycling rule 발생
merge(ex, ex2, by="a")


ex[ex$a>=2 & ex$b=="다",]     #ex데이터에서 a가 2보다 크거나 같고 b가 "다"인 조건을 만족하는 레코드 추출

iris                  		#내장데이터로 붓꽃에 관한 데이터
str(iris)                  	#데이터프레임의 행 개수, 열 개수, 변수 이름, 변수의 데이터 타입 등을 확인 가능
head(iris, n=10)              #iris 데이터의 상위 10개의 행 반환, n인자의 기본값은 6
tail(iris, n=10)            	#iris 데이터의 하위 10개의 행 반환, n인자의 기본값은 6


##  subset(데이터 프레임,select=c(열이름, 열이름,...)) 으로 쉽게 데이터 선택
##  subset(데이터 프레임,select=c(열이름, 열이름,...),subset=(열이름>조건))

iris_1<-subset(iris, select=-Species)
iris_1
iris_2<-subset(iris, select=c(Petal.Length, Petal.Width))
iris_2
iris_3<-subset(iris, select=c(Petal.Length, Petal.Width), subset=(Petal.Width==0.2))
iris_3
iris_4<-subset(iris, subset=(Petal.Width==0.2))
iris_4

# 4) 리스트(list) : 리스트는 (키, 값)형태로 데이터를 저장하는 연관 배열, 모든 타입의 객체를 담을 수 있고 각 원소들의 길이가 달라도 무방
#list(key1 = value1, key2 = value2, ... )

L<- list(name=c("Tom", "Jane", "Kim"), grade=c(3, 4, 4), gradation=c(F, F, T))
L

L$name                  	#리스트 L에서 키값이 name에 해당하는 원소 출력
L[2]                  		#리스트 L에서 2번째 키값에 해당하는 원소 출력(key값과 원소가 함께 출력됨), 키와 데이터 객체값을 같이 가져옴
L[[3]]                 	      #리스트 L에서 3번째 키값에 해당하는 원소만 출력, 데이터 객체값만 가져옴
L[["name"]]              	#key값의 이름으로 원소 선택
L["name"]				#[]가 한개 인거랑 [[]]인거랑 차이가 남. 위에 적혀있는것.

# 5) 배열(array) : 다차원 데이터로 행렬이 2차원이라면 배열은 3차원 또는 n차원까지 확장된 형태
# array(data,             # 배열로 생성할 데이터
#       dim,              # 배열의 차원 지정
#       dimnames)         # 차원의 이름

array(1:12, c(2,2,3))

##자주 사용하는 함수

print("Dataedu")                                #객체를 콘솔에 출력, 단일값 출력

f<-c(0, 1, 2, 3, 5, 8, 13)
cat("The Fibonacci numbers are:",f,"...\n")     #인자로 주어진 객체들을 연결하여 콘솔에 출력

rm(f)                          			#변수 삭제
f
ls()

class(iris)                               #객체의 물리적 자료형 확인
class(iris$Sepal.Length)  
mode(iris)                                #객체의 추상적 자료형 확인
mode(iris$Species)

data(iris)                                #R에 내장된 데이터셋을 불러들임
attach(iris)                              #데이터를 R 검색경로에 추가하여 변수명만으로 바로 데이터에 접근 가능하도록 함
iris$Species
Species

detach(iris)                              #데이터를 R 검색경로에서 제거
Species

str(iris)                                 #데이터의 구조 및 변수 확인
length(iris)                              #벡터의 길이 산출
nrow(iris)                                #행의 개수 산출
ncol(iris)                                #열의 개수 산출
summary(iris)                             #데이터의 기초통계량 산출 summary값으로 나오는 수치를 잘 알아야함. 시험에 잘 나옴.
table(iris$Species)                       #객체에 대한 도수분포표 생성
prop.table(table(iris$Species))           #도수분포표에 대한 범주별 비율 계산(prop.table의 인자는 반드시 표(table)이어야 함)

a <- c(40, 30, 50, 50, 90, 40, 50)
order(a)                               #벡터에 저장된 값들을 정렬한 순서대로 순서값 부여
sort(a)                                #지정한 데이터를 정렬
sort(a, decreasing=TRUE)               #decreasing=TRUE는 내림차순 정렬

##문자열 다루기 이거도 시험 문제에 나왔음.


#nchar("문자열")                           #문자열의 길이 반환
nchar("Tom")

#paste("문자열1", "문자열2",...,sep=" ")    #지정한 문자(열)를 sep에 지정한 구분자로 연결
paste("My", "name", "is", "Tom", sep=" ")

#substr("문자열", 시작번호, 끝번호)           #문자열의 시작번호부터 끝 번호까지를 추출, 공백도 취급되서 출력됨.
substr("BigData Analyals", 2, 8)

#strsplit("문자열", 구분자)                 #구분자(/)를 기준으로 문자열을 분리
path<-"r_class/bigdata/analyai"
strsplit(path, "/")


#sub("대상문자열", "변경문자열", str) str(문자열)에서 대상문자열을 찾아 변경문자열로 한 번만 바꿈
s<-"Curly is the amart one. Curly is funny, too."
sub("Curly", "Tom",s)

#gsub("대상문자열", "변경문자열", str) str(문자열)에 있는 모든 대상문자열을 변경문자열로 대치
gsub("Curly", "Tom", s)

#grep("찾을 문자열", str) str(문자열)에서 찾을 문자열이 포함된 문자열 혹은 인덱스를 출력
grep("1010",c("1001", "1010", "1110", "101000"))

##날짜 다루기 한번씩 나옴
Sys.Date()          		#현재 날짜 반환

#as.Date() 				#데이터 타입을 날짜 형식으로 변환
as.Date("2022-07-08")
as.Date("07/08/2022", format="%m/%d/%Y")

format(Sys.Date(), format="%m/%d/%y")             #현재 날짜를 format에 지정한 형태의 문자열로 변환

format(Sys.Date(), "%a")                         #요일 조회
format(Sys.Date(), "%b")                         #축약된 월 이름 조회
format(Sys.Date(), "%B")                         #전체 월 이름 조회
format(Sys.Date(), "%d")                         #두 자리 숫자로 일 조회
format(Sys.Date(), "%m")                         #두 자리 숫자로 월 조회
format(Sys.Date(), "%y")                         #두 자리 숫자로 연도 조회
format(Sys.Date(), "%Y")                         #네 자리 숫자로 연도 조회

##데이터 입출력
# 1) 데이터 불러오기

#< 공통인자 설명 >
#● header : 첫 행을 변수명으로 지정할지에 대한 여부
#● sep : 데이터셋을 불러올 때 사용할 열 구분자
#● stringsAsFactors : 문자형 데이터를 팩터로 인식하여 데이터를 불러올지에 대한 여부

#csv 데이터 파일 읽기
#read.csv("파일명", header=FALSE, sep="구분자",stringsAsFactors=TRUE, ...) 
f1<-read.csv("frame.csv",header=T)			#sep는 일반적으로 생략하는 경우가 많다.
f1

#xlsx 데이터 파일 읽기
#read.xlsx("파일명", sheetIndex=시트번호, startRow=시작 행, header=FALSE, ...) #xlsx package 설치필요
install.packages("xlsx")
library(xlsx)
f2<-read.xlsx("frame.xlsx", sheetIndex=1, startRow=1, header=T)
f2

#txt 파일을 테이블 형태로 읽기
#read.table("파일명", header=FALSE, sep="구분자",stringsAsFactors=TRUE, ...)
f3<-read.table("exam1.txt", header=T)
f3

#txt 파일을 한 줄씩 읽기
#readLines("파일명", ...)
f4<-readLines("DJKIM.txt", encoding="EUC-KR")		#깨져있음.
f4

#대용량 데이터를 빨리 읽기
#fread("파일명", header=FALSE, sep=“구분자”, ...) #data.table package 설치필요
install.packages("data.table")
library(data.table)
f5<-fread("exam1.txt", header=TRUE)
f5


# 2) 데이터 저장하기

#csv 데이터 파일 저장
#write.csv(저장할 데이터, file="파일경로/파일명", sep="구분자", row.names=TRUE, col.names=TRUE, ...)
write.csv(iris,file="iris.csv",row.names=FALSE)

#xlsx 데이터 파일 저장
#write.xlsx(저장할 데이터, file="파일경로/파일명", sheetname="시트명",col.names=TRUE, row.names=TRUE, ...)#xlsx package 설치필요
write.xlsx(iris,file="iris.xlsx")

#txt 데이터 파일 저장
#write.table(저장할 데이터, file="파일경로/파일명", sep="구분자", row.names=TRUE, col.names=TRUE, ...)
write.table(iris,"iris.txt")

#분석결과 파일에 저장하기
#sink("출력 파일 명") # R프로그램 출력 내용을 모두 파일에 저장, 출력 내용 저장을 그만하려면 sink()로 마무리

sink("regression.txt")
library(MASS)
data(Animals)
Animals
ml<-lm(log(brain)~log(body),data=Animals)
ml
summary(ml)
sink()


# 3) 사용자 정의 함수
#function(인자1, 인자2, 인자3 ,...,인자n) {
#         표현식1
#         표현식2
#         ... 표현식n
#         return(반환 값)     
#         } 
#함수 내부에 또 다른 함수를 정의하는 '중첩함수'의 정의가 가능.
#반환 값이 없는 경우에는 return() 구문의 생략이 가능.

k1<-function(x){                                    
	(x-mean(x))/sd(x)
}#정규분포를 표준정규분포로 표준화
k1(1:10)

skew.and.kurto <-function(x)        #왜도와 첨도를 구하는 함수
{
  
  
  
  
  
  
}


t5<- rt(1000,5)                    #1000 random obs from t with df 5
round(skew.and.kurto(t5),3)


# 4) 데이터 자리수 조절
# R을 기본적으로 부동소수점을 포함해 7자리를 표시

pi

# 자리수를 4자리로 표현

print(pi, digits=4)

cat(pi,"\n")

# cat 함수는 형식 조정 불가->format 함수 활용



# 옵션함수를 활용해서 digit의 기본값을 바꾸기









