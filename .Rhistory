getwd()
setwd("C://r_class")
getwd() #현재 위치
1+1;1+2
dir()                           #현재 작업 중인 폴더에 있는 파일 목록 산출
list.files()                    #파일 이름 확인하기
ls()                            #변수 목록 보기
print()                         #출력
path.package()                #현재 활성화된 패키지들이 무엇인지 확인
library(MASS)                 #MASS 패키지를 라이브러리에 설치
summary(Animals)
Animals
name<-"Jane";                        #name 변수에 Jane 이라는 문자 할당
name
number<-c(1,2,3,4,5);                        #number변수에 숫자 1,2,3,4,5를 할당
number
5^2                 # ^ : 지수
+3; -5;                 # +- : 단항 플러스와 마이너스 부호
1:30                 # ":" :수열 생성
3%/%3                 # %/% : 나눗셈의 몫
3%%3                 # %% : 나눗셈의 나머지
3%*%3                 # %*% : 행렬곱
2*5; 10/2;                 # *,/ : 곱하기, 나누기
3+4; 5-2;                 # +,- : 더하기, 빼기
3==5                 # == : 좌우의 값이 같은지 비교하여 TRUE/FALSE로 반환
3!=5; 4<1; 4>1;                 # !=,<,> : 좌우의 값이 다른지 비교하여 TRUE/FALSE로 반환
3!=5; 4<1; 4>1                 # !=,<,> : 좌우의 값이 다른지 비교하여 TRUE/FALSE로 반환
6<=3; 9>=4;                 # <=, >= : 크거나 같다, 작거나 같다를 비교하여 TRUE/FALSE로 반환
8<=3; 9>=4;                   # <=, >= : 크거나 같다, 작거나 같다를 비교하여 TRUE/FALSE로 반환
!(3==4)                 # ! : 논리 부정
3==4 & 4==3                 # & : 논리 AND로 논리 연산 데이터가 하나일 때 &&, 하나 이상일 때 &
5==3 | 3==2                 # | : 논리 OR로 논리 연산 데이터가 하나일 때 ||, 하나 이상일 때 |
y~a*x+b                 # ~ : 식(formula)로 종속변수 ~ 독립변수1 + 독립변수2 ...
y~a*x+b                  # ~ : 식(formula)로 종속변수 ~ 독립변수1 + 독립변수2 ... y=ax+b의 표현
a<-c(1.1,-5)
a
b<-c("Bigdata")
b
a<-c(1,-5)
a
(3==4)
(4==4)
(3==4)+(4==4)+(5==4)
성별<-factor(c("M","M","F","F","F"), levels=c("F","M"), labels=c("여","남"), ordered=F)
성별
45*4
180/4
c<-c)1,3,"dog",NA,NULL)                        #NA의 경우 벡터에 입력했을 때 나타나지만, NULL의 경우 정의되지 않은 값이므로 나타나지 않음
c<-c)1,3,"dog",NA,NULL)
c<-c(1,3,"dog",NA,NULL)
c                        #NA의 경우 벡터에 입력했을 때 나타나지만, NULL의 경우 정의되지 않은 값이므로 나타나지 않음
1/0                      #inf
0/0                        #NaN
a<-c(1.1,-5)    
b<-c("Bigdata")
c<-factor(c("M","M","F","F","F"), levels=c("F","M"), 
          labels=c("여","남"), ordered=F)
d<-(3==4)
is.numeric(a)                #객체가 숫자형 벡터인가?
is.integer(a)                #객체가 숫자형 벡터인가?
is.double(a)                #객체가 숫자형 벡터인가?
is.character(a)                #객체가 문자형 벡터인가?
is.character(b)                #객체가 문자형 벡터인가?
is.factor(c)                #객체가 팩터인가?
is.logical(a)                #객체가 논리형인가?
is.logical(d)                #객체가 논리형인가?
is.null(a)                #객체가 NULL인지 판단
is.na(b)           #객체가 NA인지 판단
나이<-c(24,26,25,20,40,39,"29")                 #마지막 "29"로 인해 character형으로 생성됨
과목<-c("R","Python","Java","C","R","R","Java") 
성별<-factor(c("F","M","F","M","M","M","F"))
나이
sum(나이)
as.numeric(나이)                    #객체를 숫자형으로 변환
성별<-factor(c("F","M","F","M","M","M","F"))
성
성별
as.character(성별)                    #객체를 문자형으로 변환
과목<-c("R","Python","Java","C","R","R","Java") 
과목
as.factor(과목)                    #객체를 팩터로 변환
과목
as.factor(과목)                    #객체를 팩터로 변환
as.factor(과목)                    #객체를 팩터로 변환
as.factor(과목)                    #객체를 팩터로 변환
z<-c(6,7,8,9,10)                  #벡터 생성(원소 중 하나라도 문자형이 있으면 모두 문자형으로 변형됨)
z
z[2]                  #v벡터의 두 번째 원소 출력
z[c(1,3)]                  #z벡터의 첫 번째, 세 번째 원소 출력
z[-5]                  #z벡터의 다섯 번째 원소만 제외하고 출력
z[2:4]
z[1,3]
name(z)<-c("Kim","Lee","Park","Choi","Jeong");
z["Park"];                  #결과로 원소 이름이 Park인 8이 출력됨
name(z)<-c("Kim","Lee","Park","Choi","Jeong");
name(z)<-c("Kim","Lee","Park","Choi","Jeong");
z<-c(6,7,8,9,10)           #벡터 생성(원소 중 하나라도 문자형이 있으면 모두 문자형으로 변형됨)
name(z)<-c("Kim","Lee","Park","Choi","Jeong");
names(z)<-c("Kim","Lee","Park","Choi","Jeong");
z["Park"];                  #결과로 원소 이름이 Park인 8이 출력됨
z[z>7]                  #z벡터의 원소 중 7보다 큰 값만 출력
rep(c("k",1), times=c(3,6))                            #k를 3번, 1을 6번 반복
rep(1:3, each=10)                            #1,2,3을 각각 10번씩 반복
rep(c("k",1), times=c(3,6))                            #k를 3번, 1을 6번 반복
rep(1:3, each=10)                            #1,2,3을 각각 10번씩 반복
seq(from=1, to=10, by=2)                            # 1부터 10까지 2만큼 증가하는 수열
b<-v(1,10)
b<-c(1,10)
b
필기점수<-c(89,86,85,92,93,91,90,89,81,84,85,89,92,95,96,91,93,92,90,90,92,91,93,92,90,92,92,93,94,99,95,96,94)
실기점수<-c(91,87,95,96,89,87,86,85,84,86,88,92,91,93,92,92,91,93,94,94,95,96,96,96,99,95,98,97,92,86,84,89,87)
mean(필기점수)                          #변수의 평균 출력
sum(필기점수)                          #변수의 합계 출력
max(필기점수)                          #변수의 최대값 출력
min(필기점수)                          #변수의 최솟값 출력
median(필기점수)                          #변수의 중앙값 출력
abs(필기점수)                          #변수의 절댓값 출력
log(필기점수)                          #변수의 로그값 출력
log(필기점수)                          #변수의 로그값 출력
sd(필기점수)                          #변수의 표준편차 출력
var(필기점수)                          #변수의 분산 출력
cov(필기점수, 실기점수)                          #변수간 공분산 출력
cor(필기점수, 실기점수)                          #변수간 상관계수 출력
length(필기점수)                          #벡터의 길이(원소 개수)를 값으로 산출
abs(필기점수)                          #변수의 절댓값 출력
log(필기점수)                          #변수의 로그값 출력
log(필기점수)                          #변수의 로그값 출력
log(필기점수)                          #변수의 로그값 출력
log(필기점수)                          #변수의 로그값 출력
log(필기점수)                          #변수의 로그값 출력
log(필기점수)                          #변수의 로그값 출력
)                          
log(필기점수)                          #변수의 로그값 출력
v1<-c(10,11,12,13,14)
v2<-c(1,2,3,4,5)
v1+v2
v1-v2
v1*v2
v1^v2
v1/v2
v1+2
v1-2
v1*2
v1/2
v1/2
mean(v1)
v1-mean(v1)
(v1-mean(v1)/sd(v1)
(v1-mean(v1)/sd(v1)
(v1-mean(v1)/sd(v1)
(v1-mean(v1)/sd(v1)
(v1-mean(v1)/sd(v1)
(v1-mean(v1)/sd(v1))
###### recycling rule  ########
a<-c(1,2,3,4,5,6)
(v1-mean(v1)/sd(v1))
(v1-mean(v1)/sd(v1))
a<-c(1,2,3,4,5,6)
b<-c(7,8,9)
a+b
matrix(1:9, nrow=3, ncol=3, dimnames(c("r1","r2","r3"), c("a","b","c")))
matrix(1:9, nrow=3, ncol=3, dimnames=list(c("r1","r2","r3"), c("a","b","c")))
matrix(1:9, nrow=3, ncol=3, byrow=T, dimnames=list(c("r1","r2","r3"), c("a","b","c")))
matrix(1:9, nrow=3, ncol=3, dimnames=list(c("r1","r2","r3"), c("a","b","c")))
matrix(1:9, nrow=3, ncol=3, byrow=T, dimnames=list(c("r1","r2","r3"), c("a","b","c")))
x<-c(1:9)
x
dim(x)<-c(3,3)               #dim()은 행렬 차원 확인 및 부여하는 함수. 
x
x               #x행렬에 3x3차원 부여
nrow(x)               #행의 수 확인
ncol(x)               #열의 수 확인
x[2,2]               #x행렬의 2행2열의 원소 추출
x[2,]               #x행렬의 2행의 원소 추출
x[,1]               #x행렬의 1열의 원소 추출
x[2,]               #x행렬의 2행의 원소 추출
x[,1]               #x행렬의 1열의 원소 추출
x[-3,]               #x행렬의 3행을 제외한 나머지 행 추출
x[,-2]               #x행렬의 2열을 제외한 나머지 열 추출
x
dimnames(x)<-list(c("r1","r2","r3"),c("a","b","c"))                                       # 행렬의 각 차원의 이름 부여
x                  
rownames(x)<-c("r4","r5","r6")                                #행 이름 출력 및 부여
x
colnames(x)<-c("e","f","g")                                 #열 이름 출력 및 부여
x
t(x)                #x의 전치행렬 반환
diag(x)                #행렬 x의 대각원소 반환
y<-matrix(1:4,2,2)
y
z<-matrix(5:8,2,2)
z
solve(y)               #y의 역행렬 반환
y+z; y-z;               #y,z 행렬의 각 원소간의 덧셈/뺄셈
y+3                #y행렬의 각 원소에 숫자 3을 더함
y*3                #y행렬의 각 원소에 숫자 3을 곱함
y%*%z                #y행렬과 z행렬 간의 곱셈
y<-matrix(1:4,2,2)
y
z<-matrix(5:8,2,2)
z
y%*%z                #y행렬과 z행렬 간의 곱셈
q()
